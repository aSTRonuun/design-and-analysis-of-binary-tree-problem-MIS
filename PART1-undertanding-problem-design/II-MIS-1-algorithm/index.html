<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algorithm 1</title>
</head>
<body>
    <h3>Pseudocódigo</h3>

    <pre>
        <code>
            0 -  Node {
            1 -    dados
            2 -    esquerda
            3 -    direita
            4 -  
            5 -    Node(dados) {
            6 -      this.dados = dados
            7 -      this.esquerda = this.direita = null
            8 -    }
            9 -  }
            10 -
            11 -  FindMISSize(noRaiz) {
            12 -    if (noRaiz == null) 
            14 -      retorne 0
            15 -  
            16 -    filhoEsquerda = noRaiz.esquerda
            17 -    filhoDireita = noRaiz.direita
            18 -    excluir = FindMISSize(filhoEsquerda) + FindMISSize(filhoDireita)
            19 -    incluir = 1
            20 -  
            21 -    if (filhoEsquerda != null) {
            22 -      netoEsquerda = filhoEsquerda.esquerda
            23 -      netoDireita = filhoEsquerda.direita
            24 -      incluir += FindMISSize(netoEsquerda) + FindMISSize(netoDireita)
            25 -    }
            26 -  
            27 -    if (filhoDireita != null) {
            28 -      netoEsquerda = filhoDireita.esquerda
            29 -      netoDireita = filhoDireita.direita
            30 -      incluir += FindMISSize(netoEsquerda) + FindMISSize(netoDireita)
            31 -    }
            32 -    retorne max(excluir, incluir)
            33 -  }
        </code>
    </pre>

    <h3>Justifique sua corretude</h3>
    Para provar a corretude do algoritmo podemos usar a seguinte método de indução para pecorrer a árvore e calcular o MIS:

    <p>
        Assim, queremos provar que P(n) = "FindMISSize(root)" retorna a quantidade de elementos do Conjunto Independente Máximo, para qualquer tamanho da árvore.
    </p>

    <p>
        Caso Base: Se a quantidade de nós na arvore for igual a 0, ou seja, a raiz da árvore é nula, temos que por conta do condional ele retornará 0. Logo, P(0) vale.
    </p>

    <p>
        Considere algum n > 0
        Hipótese: P(k) vale, para 0 <= K < n.
    </p>

    <p>
        Dado que, o algoritmo recebe uma árvore que contém sub-árvores, ou seja, com a quantidade de nós > 0, ele faz uma chamada recursiva passando o filho direito e filho esquedo do nó atual, caso sejam nulos o primeiro condional retornará 0 e voltará e retrocederá na pilha de chamadas até a instância que invocou as chamada, caso contrário, farará com que a várivel excluir¹ receba um valor > 0. Caso não sejam nulos, chamará recursivamente até o último nó que contém nós nulos, quando chegar nessa caso será possível incrementar o valor da varível incluir², para assim, demonstrar que esse é um nó independente. Ademais, vai ser verificado se os filhos da direita e da esquerda atual são nulos, se não forem nulos, irá ser possível incrementar o valor chamando recursivamente os netos da esquerda e da direita do nó atual, se ouver netos não nulos, irá retornar valores > 0, incrementendando, assim, a variável incluir. Desse modo, passado todas as chamadas recursivas, o valor de incluir e excluir são comparados a fim de retornar o valor máximo e assim, podemos provar que o algoritmo tem execução finita e retorna a quantidade de elementos e, portanto, P(K) vale nesse caso.
    </p>


    <h3>Exemplo de execução</h3>
    <p>
        <img width="1000px" src="./BackTrackRecursive.png" alt="Exemplo 1">
    </p>
</body>
</html>